# 1. 알고리즘의 시간 복잡도

## 1) 자료 vs 자료구조

* `자료 == Data`

  * int, float 같은 것을 <u>자료형</u>이라고 하고, **데이터를 메모리(RAM)에 저장**한다.
  * ex) 3 - 연산 불가(메소드 없음!)

* `자료 구조 == Data Structure`

  * 데이터를 읽기, 쓰기, 삽입, 삭제, 탐색할 수 있는 **연산 기능을 제공**한다.
  * ex) [3, 4, 5] - <u>append, pop, remove, insert 등 메소드로 연산가능!</u>
  * 다수의 데이터를 효율적으로 저장하고 조작할 수 있으므로, **<u>자료 구조가 알고리즘 구현의 기본 재료가 된다!</u>**

  > 즉, **자료구조의 특성**을 알아야 알고리즘을 구현할 수 있다!




## 2) 알고리즘 소요시간

### (1) 알고리즘 성능 평가기준

* 좋은 알고리즘이란 무엇일까요?

  * 효율성이 좋은 알고리즘
  * 성능이 좋은 알고리즘

  > 시간 복잡도의 측면에서, Input을 넣은 후 **Output이 나오는 시간이 <u>짧게 걸리는</u> 알고리즘!**



### (2) 알고리즘 소요시간 측정방법

* 그렇다면 알고리즘 소요 시간은 어떻게 측정할까요?

1. **타이머로 재기**
   * 컴퓨터 사양, 하드웨어 성능에 따라 같은 알고리즘이라도 측정시간이 달라짐. 환경에 영향을 받지 않는 <u>객관적 기준</u>이 필요!

2. **기본연산 횟수**

   * `기본연산`이란 단위시간 1이 소요되는 기본적인 연산. 즉, 단위 연산
     * ex) 할당, 산술, 비교, 반환 ...

    * 즉, `기본연산의 총 횟수 == 알고리즘의 소요 시간`


   * 예시 코드에서 기본연산 횟수를 세어보자

      ```python
        def count(word, char):    #input
            total = 0
            for i in word:
                if i == char:
                    total += 1
            return total          #output
      
      count("apple", "p")
      ```

      * `total = 0`은 연산 1개 (할당)
      * `for i in word` 는 연산 5개 (i가 할당될 때마다 1개)
      * `i == char` 는 연산 5개 (5개 i를 각각 char와 비교)
      * `total += 1` 은 연산 4개 (덧셈, 할당이 2번 일어남)
      * 총 15번의 연산이 일어남. 즉, 알고리즘 소요시간 == 15

   * 하지만, <u>입력에 따라 알고리즘별 소요시간 크기우위가 달라질 수도 있음!</u> (어떨 때는 A알고리즘이 빠르고, 다른 때는 B알고리즘이 빠르게 나오고...)

3. **최악의 입력**

   * 가장 기본연산이 많이 일어나는 <u>최악의 입력 n개</u>가 들어온다고 가정하고 측정한다.

   * 즉, 위의 total += 1 연산이 매번 실행되는 경우

    ```python
    count("aaaaa","a")
    ```



## 3) 시간 복잡도와 Big-O 표기법

### (1) **시간 복잡도(Time Complexity)란 ?**

* 단순하게 <u>알고리즘의 수행 시간</u>을 의미
  
  > 시간 복잡도가 높으면 느린 알고리즘!
  >
  > 시간 복잡도가 낮으면 빠른 알고리즘!



* 시간복잡도에 따라 <u>알고리즘의 성능을 비교</u>해보자

  * Input이 `n`개일 때 작성자별 시간 복잡도를 수식으로 나타내면?

    * A 작성자 : 6n + 4 (시간 복잡도가 <u>선형으로 증가</u>)

    * B 작성자 : 3n + 2 (<u>선형 증가</u>)
    * C 작성자 : 3n^2 + 6n + 1 (<u>제곱으로 증가</u>)
    * Input이 `1`개 일 때) A : 10, B : 5, C : 10
    * Input이 `5`개 일 때) A : 34, B : 17, C : 94

  * **n이 무한대라면?** A, B작성자는 비교의 의미가 없다. C 작성자는 의미가 있다.



### (2) Big-O 표기법이란?

* 입력 n이 무한대로 커진다고 가정하고 시간 <u>복잡도를 간단하게 표시</u> 하는 것

  * 수 많은 알고리즘이 있기 때문에 최대한 간단히 표시하자! (약속)

* **<u>최고차항</u>만 남기고 계수와 상수를 제거**

  * A 작성자 : O(n)

  * B 작성자 : O(n)

  * C 작성자 : O(n^2)

* <u>다양한 시간 복잡도 종류 살펴보기</u>

  * O(2^n)
  * O(n^2)
  * O(n log n)
  * O(n) : 입력이 변함에 따라 n에 비례하여 시간복잡도가 변함
  * O(log n) : log n은 log2가 생략되어있음. 
  * O(1) : 입력이 변해도 입력 1개만 시간복잡도 검사

* <u>실제 문제에서</u> 어떻게 적용?

  * 실제 문제는 "초" 단위로 제한 시간이 주어지고, 시간복잡도도 정확히 예측하기 어렵다.

  * 어림짐작 해서, **보통 컴퓨터는 1초에 1억 번 연산으로 계산 (국룰)**

  * 즉, 시간제한이 1초일 때 n개 입력을 넣으면 알고리즘 전체 연산이 1억번 이하로 나와야 함!

  * 아래와 같은 문제를 풀어보자.

    ```markdown
    문제 : 연속된 숫자들의 합 구하기
    제한 시간 : 1초
    입력 : 자연수 N이 입력된다. (1 <= N <= 1,000,000,000)
    출력 : 
    ```

    ```python
    ## 첫 번째 방법 - 일일히 더하기
    
    def get_total(n):
    	total = 0
        for i in range(1, n+1):
            total += i
        return total
    
    print(get_total(10))     #O(n), 10을 넣으면 10번 계산, 10억번 넣으면 10억번 계산(계산이 엄청 오래 걸림)
    ```

    ```python
    ## O(1)로 풀 수 있을까?
    
    def get_total(n):
    	return (n + (n+1)) // 2
    
    print(get_total(1000000000))    #O(1)이기 때문에 넣으면 바로 나옴!
    ```

  * 입력 n개로 for문 1번 돌아가면 O(n), O(n^2)은 이중 for문이라고 생각하면 됨.

  * **같은 동작을 하는 알고리즘이라 하더라도 시간 복잡도에 따른 성능이 달라지고, 곧 시험에서 취업 여부가 달라진다!**

  * 내장 함수, 메서드의 시간복잡도가 모두 달라 확인할 필요가 있다!

    ![Big O Cheat sheet](220222_algorithm_day2.assets/image-20220222125947753.png)

  * 즉, for문 1번이라고 무조건 O(n)인것이 아니다. <u>for문 안에 O(n)의 내장 함수(replace 등)를 사용했다면, 이중 for문과 다를게 없기 때문!!!</u>

